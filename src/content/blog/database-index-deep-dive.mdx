---
title: "데이터베이스 인덱스 깊게 파헤치기: B-Tree부터 실행계획까지"
date: 2024-11-15
summary: "인덱스의 원리부터 실무에서 자주 마주치는 인덱스 최적화 패턴까지 정리합니다."
tags: ["Database", "Index", "MySQL", "PostgreSQL", "Performance"]
category: "cs"
---

## 들어가며

"인덱스 걸었는데 왜 안 타죠?"라는 질문은 백엔드 개발자라면 한 번쯤 해봤을 것입니다. 이 글에서는 인덱스의 근본 원리부터 실무에서 마주치는 다양한 케이스를 정리합니다.

## 인덱스란?

인덱스는 **테이블의 검색 속도를 높이기 위한 자료구조**입니다. 책의 색인(Index)처럼 원하는 데이터를 빠르게 찾을 수 있게 해줍니다.

### Full Table Scan vs Index Scan

```sql
-- 인덱스 없이 조회: O(n)
SELECT * FROM users WHERE email = 'user@example.com';

-- 인덱스 있으면: O(log n)
CREATE INDEX idx_users_email ON users(email);
SELECT * FROM users WHERE email = 'user@example.com';
```

## B-Tree 인덱스의 구조

대부분의 RDBMS에서 기본으로 사용하는 B-Tree 인덱스의 구조를 살펴봅니다.

### B-Tree의 특징

- **균형 트리**: 모든 리프 노드가 같은 깊이
- **정렬 유지**: 키 값이 정렬된 상태로 저장
- **범위 검색 효율**: 리프 노드 간 연결로 범위 검색 최적화

```
                    [50]
                   /    \
            [20, 35]    [70, 85]
           /   |   \    /   |   \
        [10] [25] [40] [60] [80] [95]
         ↓    ↓    ↓    ↓    ↓    ↓
       Data  Data Data Data Data Data
```

### 왜 B-Tree인가?

1. **디스크 I/O 최소화**: 노드당 여러 키 저장 → 트리 높이 감소
2. **순차 접근 효율**: 리프 노드가 연결 리스트로 연결
3. **삽입/삭제 효율**: O(log n) 유지

## 인덱스가 동작하지 않는 경우

### 1. 컬럼 변형

```sql
-- ❌ 인덱스 사용 불가
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- ✅ 인덱스 사용 가능
SELECT * FROM users 
WHERE created_at >= '2024-01-01' 
  AND created_at < '2025-01-01';
```

### 2. 묵시적 타입 변환

```sql
-- phone이 VARCHAR 타입일 때
-- ❌ 숫자로 비교하면 인덱스 사용 불가
SELECT * FROM users WHERE phone = 01012345678;

-- ✅ 문자열로 비교
SELECT * FROM users WHERE phone = '01012345678';
```

### 3. OR 조건

```sql
-- ❌ 인덱스 효율 저하
SELECT * FROM users WHERE name = 'Kim' OR age = 25;

-- ✅ UNION으로 분리
SELECT * FROM users WHERE name = 'Kim'
UNION
SELECT * FROM users WHERE age = 25;
```

## 복합 인덱스 설계

### 선두 컬럼의 중요성

```sql
CREATE INDEX idx_composite ON orders(user_id, status, created_at);

-- ✅ 인덱스 사용 (선두 컬럼 포함)
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 1 AND status = 'COMPLETED';

-- ❌ 인덱스 사용 불가 (선두 컬럼 없음)
SELECT * FROM orders WHERE status = 'COMPLETED';
```

### 카디널리티 고려

카디널리티(Cardinality)가 높은 컬럼을 선두에 배치:

```sql
-- user_id: 높은 카디널리티 (고유값 많음)
-- status: 낮은 카디널리티 (몇 가지 값만 존재)

-- ✅ 좋은 설계
CREATE INDEX idx_orders ON orders(user_id, status);

-- ❌ 비효율적
CREATE INDEX idx_orders ON orders(status, user_id);
```

## 실행 계획 읽기

### MySQL EXPLAIN

```sql
EXPLAIN SELECT * FROM users WHERE email = 'user@example.com';
```

주요 확인 포인트:
- `type`: ALL(풀스캔) < index < range < ref < const
- `key`: 실제 사용된 인덱스
- `rows`: 예상 스캔 행 수
- `Extra`: Using index(커버링), Using filesort(정렬) 등

### PostgreSQL EXPLAIN ANALYZE

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user@example.com';
```

실제 실행 시간과 예상치의 차이를 확인할 수 있습니다.

## 커버링 인덱스

인덱스만으로 쿼리를 처리할 수 있으면 테이블 접근이 불필요합니다.

```sql
-- user_id, status만 필요한 경우
CREATE INDEX idx_covering ON orders(user_id, status);

-- ✅ 커버링 인덱스 활용 (Extra: Using index)
SELECT user_id, status FROM orders WHERE user_id = 1;

-- ❌ 추가 컬럼 필요 시 테이블 접근 발생
SELECT * FROM orders WHERE user_id = 1;
```

## 마무리

인덱스는 단순히 "걸면 빨라진다"가 아닙니다. 구조를 이해하고, 실행 계획을 확인하며, 상황에 맞게 설계해야 합니다.

### 핵심 요약

1. B-Tree 구조와 동작 원리 이해
2. 인덱스가 동작하지 않는 패턴 숙지
3. 복합 인덱스는 선두 컬럼과 카디널리티 고려
4. EXPLAIN으로 항상 검증

## 참고 자료

- [MySQL 8.0 Reference Manual - Optimization and Indexes](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)
- [Use The Index, Luke!](https://use-the-index-luke.com/)
