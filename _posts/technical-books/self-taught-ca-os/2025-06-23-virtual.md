---
title: "Chapter14 가상 메모리"
excerpt: "혼자 공부하는 컴퓨터 구조 + 운영체제"

categories:
  - Self-Taught Computer Architecture and Operating Systems
tags:
  - [tag1, tag2]

permalink: /self-taught-ca-os/virtual/

toc: true
toc_sticky: true

date: 2025-06-23
last_modified_at: 2025-06-23
---


## 1 연속 메모리 할당

***

## 2 페이징을 통한 가상 메모리 관리

***

## 3. 페이지 교체와 프레임 할당

가상 메모리는 물리 메모리보다 큰 프로그램을 실행할 수 있도록 해 주지만, 현실적으로 물리 메모리의 크기는 제한적입니다.  
따라서 운영체제는 프로세스들이 제한된 메모리를 효율적으로 사용할 수 있도록, **불필요한 페이지는 제거하고, 필요한 페이지만 메모리에 적재하는 방식**으로 관리해야 합니다.

또한 각 프로세스가 사용할 수 있는 **프레임(Frame)**의 수를 적절히 조절해야, 시스템 전체 성능을 저하시키지 않고 안정적으로 운영할 수 있습니다.

---

### 요구 페이징(Demand Paging)

**요구 페이징**은 프로그램을 실행할 때, **처음부터 모든 페이지를 메모리에 올리지 않고**, CPU가 접근하는 시점에 필요한 페이지만 메모리에 적재하는 기법입니다.

#### 동작 과정
1. CPU가 명령어를 수행하며 특정 페이지를 요청
2. 해당 페이지가 메모리에 있으면 → 정상적으로 접근
3. 페이지가 없으면 → **페이지 폴트(Page Fault)** 발생
4. 운영체제가 디스크에서 해당 페이지를 메모리로 로드
5. 페이지 테이블을 갱신하고 명령을 재실행

#### 순수 요구 페이징(Pure Demand Paging)
- 시작 시 아무 페이지도 메모리에 적재하지 않음
- 첫 명령어 실행 시점부터 연속적인 페이지 폴트가 발생
- 초기에 느릴 수 있으나, **불필요한 페이지를 적재하지 않음으로써 메모리 효율 향상**

요구 페이징은 메모리를 절약할 수 있다는 장점이 있지만, 메모리가 가득 찬 상황에서는 **새로운 페이지를 넣기 위해 기존 페이지를 제거**해야 하므로, 이때 어떤 페이지를 제거할지를 결정하는 **페이지 교체 알고리즘**이 필요합니다.

---

### 페이지 교체 알고리즘(Page Replacement Algorithm)

페이지 교체 알고리즘은 메모리가 가득 찬 상태에서 **어떤 페이지를 제거할지 결정하는 방식**입니다.

좋은 알고리즘은 다음 조건을 만족해야 합니다:

- 페이지 폴트 수를 **최소화**할 수 있어야 함
- 구현이 효율적이고, 과도한 오버헤드를 발생시키지 않아야 함

**성능 평가는 페이지 참조열(reference string)**과 **페이지 폴트 횟수**를 통해 비교합니다.

---

#### FIFO (First-In First-Out)
- 가장 먼저 메모리에 들어온 페이지를 가장 먼저 제거
- **큐(Queue)** 구조로 간단하게 구현 가능
- 단점: **최근 사용 여부를 고려하지 않음**
- 성능이 떨어질 수 있음 (예: Belady의 모순 현상)

**예시**  
참조열: `2 3 1 3 5 2 4 2 3`  
프레임 수: 3 → 페이지 폴트 수: **6회**

---

#### 2차 기회 알고리즘 (Second-Chance)
- FIFO의 개선 버전
- 페이지마다 **참조 비트(Reference Bit)**를 두어, 교체 전에 확인
- 참조 비트가 `1`이면 → 0으로 초기화하고 페이지를 큐 뒤로 이동 (기회 한 번 더 줌)
- 자주 사용된 페이지는 제거되지 않음

---

#### 최적 페이지 교체 (Optimal Replacement)
- **앞으로 가장 오랫동안 사용되지 않을 페이지**를 제거
- 페이지 폴트 수가 이론적으로 가장 적음 → **비교 기준**으로 사용됨
- 단점: 미래의 참조를 알 수 없기 때문에 **실제 구현 불가**

---

#### LRU (Least Recently Used)
- **가장 오랫동안 사용되지 않은 페이지**를 제거
- 최근 사용 이력을 바탕으로 판단
- 실제 시스템에서도 많이 사용됨
- 구현 방식: 타임스탬프 방식, 스택 방식 등

**예시**  
참조열: `2 3 1 3 5 2 4 2 3`  
프레임 수: 3 → 페이지 폴트 수: **3회**

---

### 스레싱(Thrashing)

스레싱은 **페이지 폴트가 과도하게 발생하여**, CPU가 실질적인 작업보다 **계속해서 페이지 교체 작업만 수행**하는 비정상적인 상태입니다.

#### 특징
- CPU 사용률 급격히 감소
- 페이지 폴트율 급증
- 시스템 전체 응답 지연, 성능 급락

#### 발생 원인
- 각 프로세스에 할당된 프레임 수가 **너무 적은 경우**
- 너무 많은 프로세스가 동시에 실행되는 경우 (과도한 멀티프로그래밍)

스레싱을 방지하려면 **프레임을 적절히 할당**해야 하며, 이를 위해 다음과 같은 프레임 할당 전략이 사용됩니다.

---

### 프레임 할당 방식

#### 균등 할당 (Equal Allocation)
- 모든 프로세스에 **동일한 수의 프레임**을 분배
- 구현이 단순하고 공정성 확보 가능
- 하지만 프로세스의 크기나 메모리 요구량을 반영하지 못함

#### 비례 할당 (Proportional Allocation)
- 프로세스의 크기나 요구 메모리에 **비례하여 프레임을 할당**
- 자원을 보다 **효율적으로 분배**할 수 있음

#### 작업 집합 모델 (Working Set Model)
- **최근 일정 시간 동안 사용된 페이지 집합(작업 집합)**을 기준으로 프레임을 동적으로 조절
- 사용하지 않는 페이지는 제거하고, 자주 쓰는 페이지에 프레임을 집중
- **스레싱 방지에 효과적**

---

### 정리

- 요구 페이징은 가상 메모리의 효율성을 높이기 위한 핵심 기법이며, 페이지 교체 알고리즘과 함께 사용됨
- FIFO, LRU, Optimal 등 다양한 교체 방식은 상황에 따라 성능 차이가 큼
- 스레싱은 프레임 부족이 원인이며, 적절한 프레임 할당 정책으로 완화 가능
- 실제 운영체제는 LRU의 변형, 2차 기회 알고리즘, 작업 집합 모델 등을 조합하여 사용



