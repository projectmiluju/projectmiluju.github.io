---
title: "데이터베이스 인덱스"
excerpt: "매일메일CS"

categories:
  - Back-end
tags:
  - [tag1, tag2]

permalink: /maeil-mail-backend/7/

toc: true
toc_sticky: true

date: 2025-04-04
last_modified_at: 2025-04-04
---

## 데이터베이스 인덱스란?

> 인덱스란 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.   
> 저장되는 컬럼의 값을 사용하여 항상 정렬된 상태를 유지하는 것이 특징   
> 인덱스가 많아질수록 데이터를 추가, 변경, 삭제할 때 일이 많아져서 속도가 느려지기에 `INSERT` `UPDATE` `DELETE`의 성능이 희생된다는 단점이 있다.

***

## 인덱스는 어떤 자료 구조로 이루어져 있을까?

> B+Tree와 같은 변형 B-Tree 자료구조를 이용해서 인덱스를 구현   
> 기본 토대는 B-Tree 인덱스이기 때문에 이를 기준으로 설명   
> B-Tree 인덱스는 컬럼의 값을 변형하지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지   
> B-Tree(Balanced-Tree)에서는 크게 3가지 노드가 존재    
> 최상위에 하나의 루트 노드가 존재하며, 가장 하위 노드인 리프 노드가 존재   
> 이 두 노드의 중간에 존재하는 브랜치 노드가 존재   
> 최하위 노드인 리프 노드에는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.    
> InnoDB 스토리지 엔진에서는 세컨더리 인덱스(프라이머리 인덱스를 제외한 모든 인덱스)의 리프 노드에는 레코드의 PK가 저장   
> 따라서 세컨더리 인덱스 검색에서는 레코드를 읽기 위해 PK를 가지고 있는 B-Tree를 다시 한번 검색해야한다.

***

## MySQL 스캔방식

> `인덱스 레인지 스캔` : 검색할 인덱스의 범위가 결정되었을 경우 가장 빠름
>> * 인덱스에서 조건을 만족하는 값이 저장된 시작 리프 노드를 찾는다. `index seek`
>> * 시작 리프 노드부터 필요한 만큼 인덱스를 차례대로 읽는다. `index scan`
>> * 인덱스 키와 레코드 주소를 이용해 저장된 페이지를 가져오고 레코드를 읽어온다.  
>>

> `인덱스 풀 스캔` : 인덱스를 사용하지만 인덱스를 처음부터 끝까지 모두 읽는 방식
>> * 인덱스를 ABC 순서로 만들었는데 조건절에 B 혹은 C로 검색하는 경우 사용
>> 

> `루스 인덱스 스캔` : 듬성듬성하게 인덱스를 읽음
>> * 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리
>> * `group by` `max()` `min()` 함수에 대해 최적화하는 경우 사용