---
title: "동일성과 동등성"
excerpt: "매일메일CS"

categories:
  - Back-end
tags:
  - [tag1, tag2]

permalink: /maeil-mail-backend/414/

toc: true
toc_sticky: true

date: 2025-04-14
last_modified_at: 2025-04-27
---

## equals()와 ==의 차이

> `equals()`는 객체의 내용을 비교한다.     
> `==`는 객체의 레퍼런스를 비교한다.   
> 따라서 두 객체의 내용이 같더라도 서로 다른 객체라면 `equals()`는 true를 반환할 수 있지만 `==`는 false를 반환한다.

***

## 동등성(Equality)

> 동등성은 논리적으로 객체의 내용이 같은지를 비교하는 개념이다.    
> 자바에서는 `equals()` 메서드를 사용하여 객체의 동등성을 비교한다.****
> 
> ```java
> public class Apple {
>
>    private final int weight;
>
>    public Apple(int weight) {
>        this.weight = weight;
>    }
>
>    @Override
>    public boolean equals(Object o) {
>        if (this == o) return true;
>        if (o == null || getClass() != o.getClass()) return false;
>        Apple apple = (Apple) o;
>        return weight == apple.weight;
>    }
>
>    @Override
>    public int hashCode() {
>        return Objects.hashCode(weight);
>    }
>
>    public static void main(String[] args) {
>        Apple apple = new Apple(100);
>        Apple anotherApple = new Apple(100);
>
>        System.out.println(apple.equals(anotherApple)); // true
>    }
>   }
> ```

***

## 왜 equals() 메서드를 오버라이딩을 할까?

> ```java
> public class Object {
>    ...
>    public boolean equals(Object obj) {
>        return (this == obj);
>    }
>    ...
>   } 
> ```
> Object 클래스의 `equals()` 메서드는 `==` 연산자를 사용하여 동일성을 비교한다.     
> 모든 클래스는 Object 클래스를 상속하여 동일성 비교를 기본으로 동작하기 떄문에,   
> 동등성 비교가 필요한 클래스에서 필요에 맞게 equals & hashCode 메서드를 오버라이딩해야 한다.   
>

***

## 동일성(Identity)

> 동일성은 두 객체가 메모리 상에서 같은 객체인지 비교하는 개념이다.     
> 자바에서는 `==` 연산자를 사용하여 객체의 동일성을 비교한다.   
> `==` 연산자는 객체의 레퍼런스를 비교하므로, 두 변수가 동일한 객체를 가리키고 있느지를 확인한다.
> ```java
>   public static void main(String[] args) {
>    Apple apple1 = new Apple(100);
>    Apple apple2 = new Apple(100);
>    Apple apple3 = apple1;
>
>    System.out.println(apple1 == apple2); // false
>    System.out.println(apple1 == apple3); // true
>   }
>```

***   

## String은 객체인데 == 비교해도 되던데 어떻게 된걸까?

> 문자열 리터럴은 문자열 상수 풀(String Constant Pool)에 저장되기 때문에 동일한 문자열 리터럴을 참조하면 `==` 연산자가 true를 반환할 수 있다.     
> 하지만 `new` 키워드를 사용하여 문자열을 생성하면 새로운 객체가 생성되므로 `==` 연산자가 false 반환할 수 있다.     
> 따라서 문자열 비교 시 항상 `equals()` 메서드를 사용한 동등성 비교를 하는 것이 좋다.     
> 

***